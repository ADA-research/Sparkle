#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import os
import time
import random
import sys
import re
import logging
import subprocess
import itertools
from pathlib import Path
from subprocess import Popen, PIPE
from tempfile import NamedTemporaryFile


def get_time_pid_random_string():
	my_time_str = time.strftime('%Y-%m-%d-%H:%M:%S', time.localtime(time.time()))
	my_pid = os.getpid()
	my_pid_str = str(my_pid)
	my_random = random.randint(1, sys.maxsize)
	my_random_str = str(my_random)
	my_time_pid_random_str = my_time_str + '_' + my_pid_str + '_' + my_random_str
	return my_time_pid_random_str


def get_last_level_directory_name(filepath):
	if filepath[-1] == r'/': filepath = filepath[0:-1]
	right_index = filepath.rfind(r'/')
	if right_index<0: pass
	else: filepath = filepath[right_index+1:]
	return filepath

# Read runtime in CPU and WC time from runsolver values file
def get_runtime_from_runsolver(runsolver_values_path: str) -> (float, float):
    cpu_time = float(-1)
    wc_time = float(-1)

    with open(runsolver_values_path, 'r+') as infile:
        while True:
            line = infile.readline().strip()
            if not line:
                break
            words = line.split('=')
            # Read wallclock time from a line of the form 'WCTIME=0.110449'
            if len(words) == 2 and words[0] == 'WCTIME':
                wc_time = float(words[1])
            # Read CPU time from a line of the form 'CPUTIME=0.110449'
            elif len(words) == 2 and words[0] == 'CPUTIME':
                cpu_time = float(words[1])
                break # order is fixed, CPU is the last thing we want to read, so break from the loop

    return cpu_time, wc_time

def float_regex(self):
	return '[+-]?\d+(?:\.\d+)?(?:[eE][+-]\d+)?'


instance = sys.argv[1]
specifics = sys.argv[2]
cutoff_time = int(float(sys.argv[3]) + 1)
run_length = int(sys.argv[4])
seed = int(sys.argv[5])

params = sys.argv[6:]

relative_path = r'./'
runsolver_binary = relative_path + r'runsolver'
solver_binary = relative_path + r'Spear-32_1.2.1'

tmp_directory = relative_path + r'tmp/'
if not os.path.exists(tmp_directory):
	os.system(r'mkdir -p ' + tmp_directory)


instance_name = Path(instance).stem
solver_name = Path(solver_binary).stem
runsolver_path = tmp_directory + solver_name + '_' + instance_name + '_' + get_time_pid_random_string()
runsolver_watch_data_path = runsolver_path + '.log'
runsolver_value_data_path = runsolver_path + '.val'
runsolver_solver_data_path = runsolver_path + '.raw'

# builds the command for the Spear solver
command = "%s --seed %d --model-stdout --dimacs %s" %(solver_binary, seed, instance)

# adds extra settings to the command
len_argv = len(sys.argv)
i = 6
while i<len_argv:
	command += r' -' + sys.argv[i]
	i += 1
	command += r' ' + sys.argv[i]
	i += 1

# constructs the runsolver command
command = runsolver_binary + ' -w ' + runsolver_watch_data_path + ' -o ' + runsolver_solver_data_path + ' -v ' + runsolver_value_data_path + ' -W ' + str(cutoff_time) + r' ' + command
subprocess.call(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


with Path(runsolver_solver_data_path).open('r') as infile:
    output_list = infile.read().splitlines()
run_time, clock_time = get_runtime_from_runsolver(runsolver_value_data_path)

if run_time > cutoff_time:
    run_time = cutoff_time

# look for model (from genericWrapper4AC/domain_specific/satwrapper.py)
model = None
for line in output_list:
    line = str(line)
    if line.startswith("v "):
        model = map(int, line.split(" ")[1:-1])
        break

# Check status
status = 'CRASHED'
for line in output_list:
    line = line.strip()

    if (line == 's SATISFIABLE') or (line == 's UNSATISFIABLE'):
        status = 'SUCCESS'
        break
    elif line.startswith('c the file does not exist:'):
        status = 'CRASHED'
        break
    elif line == 's UNKNOWN':
        status = 'TIMEOUT'
        break
    elif model is None and run_time >= cutoff_time:
        status = 'TIMEOUT'
    elif run_time >= cutoff_time:
        status = 'TIMEOUT'
    elif clock_time >= cutoff_time:
        status = 'TIMEOUT'
    elif model is None:
        status = 'TIMEOUT'

if status == 'SUCCESS' or status == 'TIMEOUT':
    # Remove runsolver and raw solver output
    Path(runsolver_watch_data_path).unlink()
    Path(runsolver_value_data_path).unlink()
    # Solver output with solution (when succesful), remove because only used in configuration
    Path(runsolver_solver_data_path).unlink()

    # Remove files generated by SparrowToRiss when terminated by runsolver,
    # but executed correctly
    pathlist = Path(tmp_directory).glob('cp_*')
    pathlist2 = Path(tmp_directory).glob('model_*')

    for path in itertools.chain(pathlist, pathlist2):
        Path(path).unlink()

print('Result for SMAC: ' + status + ', ' + str(run_time) + ', 0, 0, ' + str(seed))

if specifics == 'rawres':
    raw_result_path = Path(runsolver_watch_data_path.replace('.log', '.rawres'))

    with raw_result_path.open('w') as outfile:
        for line in output_list:
            outfile.write(line)
